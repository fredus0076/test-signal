<h1>D√©mo Angular 20 ‚Äî Nouveau templating</h1>

<!-- @if / @else if / @else -->
<h2>&#64;if / &#64;else if / &#64;else</h2>
@if (status() === 'loading') {
  <p>Chargement en cours‚Ä¶</p>
} @else if (status() === 'error') {
  <p role="alert">Une erreur est survenue.</p>
} @else {
  <p>Produits charg√©s !</p>
}

<hr>

<!-- @let -->
<!-- @let -->
@let fullName = user().first + ' ' + user().last;
<p>Utilisateur : {{ fullName }}</p>

@let s = stats();
<p>Total : {{ s.total }}</p>
<p>Moyenne : {{ s.avg }}</p>

<hr>

<!-- @for + variables implicites + @empty -->
<h2>&#64;for</h2>
<ul>
  @for (p of products(); track p.id) {
    <li>
      {{ $index + 1 }}/{{ $count }} ‚Äî {{ p.name }}
      @if ($first) { <span>üÜï</span> }
      @if ($even) { <span>(pair)</span> }
    </li>
  } @empty {
    <li>Aucun produit trouv√©</li>
  }
</ul>

<hr>

<!-- @switch / @case / @default -->
<h2>&#64;switch</h2>
@switch (role()) {
  @case ('admin')  { <p>Bienvenue, administrateur</p> }
  @case ('editor') { <p>Bienvenue, √©diteur</p> }
  @default         { <p>Bienvenue, visiteur</p> }
}

<hr>

<!-- @defer avec triggers -->
<h2>&#64;defer</h2>
<button #btn>Afficher le widget</button>

@defer (on hover(btn); prefetch on idle) {
  <p>Widget charg√© dynamiquement üéâ</p>
} @placeholder {
  <p>(Survolez le bouton pour charger le widget‚Ä¶)</p>
} @loading (after 100ms) {
  <p>Chargement du widget‚Ä¶</p>
} @error {
  <p>Erreur lors du chargement.</p>
}

<p>
  {{products().length < 0}}
  <!-- 6) Condition personnalis√©e (one-shot) -->
  @defer (when products().length !== 0) {  Condition personnalis√©e (one-shot) arrive apres 8 sec (fake appel api)}
  @placeholder {
  <p style="color:red">avant de declancher</p>
} @loading {
  <p style="color:orange">Chargement du widget‚Ä¶</p>
} @error {
  <p>Erreur lors du chargement.</p>
}
</p>

<p>@defer (on interaction(btn); prefetch on idle) { click sur afficher le widget}</p>  
<!-- 
prefetch on idle est un d√©clencheur de pr√©-chargement anticip√© pour les deferrable views en Angular.
on idle est souvent combin√© avec on viewport ou on interaction ‚Üí tu √©vites le d√©lai perceptible.
Tu peux aussi utiliser prefetch on hover(element) pour anticiper juste au survol.-->
<p>
  <!-- 1) Quand l'√©l√©ment entre dans le viewport -->
  @defer (on viewport) { Quand l'√©l√©ment entre dans le viewport }
  @placeholder { <div style="color:red"></div> }
</p>

<p>
  <!-- 2) Au survol d'un bouton sp√©cifique -->
  <button #btn>Voir la carte</button>
  @defer (on hover(btn)) { Au survol d'un bouton sp√©cifique }
</p>
  
<p>
  <!-- 3) Apr√®s interaction sur une zone -->
  <a #card tabindex="0">Cliquer pour d√©tails</a>
  @defer (on interaction(card)) { Apr√®s interaction sur une zone }
</p>
<p>
  <!-- 4) Imm√©diatement apr√®s le rendu non diff√©r√© -->
  @defer (on immediate) { Imm√©diatement apr√®s le rendu non diff√©r√© }    
</p>
<p>
  <!-- 5) Apr√®s un timer -->
  @defer (on timer(5000ms)) { Apr√®s un timer 5 sec  }
</p> 

<p>Linked (explicit) value: <strong>{{linkedExplicit()}}</strong></p>

 <button 
    class="px-4 py-2 rounded bg-white hover:shadow-lg" type="button" 
    (click)="linkedExplicit.set('updated')">Update linked</button>

<button 
  class="px-4 py-2 rounded bg-white hover:shadow-lg" type="button" 
  (click)="clickOnMe()">Click Me</button>


<div>Speed</div>
<input type="text" [ngModel]="speed()" readonly />





